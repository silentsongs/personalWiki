<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="Stylesheet" type="text/css" href="static/css/wiki.css">
<link rel="Stylesheet" type="text/css" href="static/bootstrap/css/bootstrap.min.css">
<script type="text/javascript" src="static/js/jquery-2.1.4.min.js"></script>
<script type="text/javascript" src="static/bootstrap/js/bootstrap.min.js"></script>
<script type="text/javascript" src="static/js/wiki.js"></script>
<title>minimun_depth_of_binary_tree</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>
<nav class="navbar navbar-default navbar-inverse" role="navigation">
	<div class="container">
		<div class="navbar-header">
		<button data-target=".bs-navbar-collapse" data-toggle="collapse" type="button" class="navbar-toggle">
			<span class="sr-only"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>
		<a class="navbar-brand" href="index.html">BlueBird's Wiki</a>
		</div>
		<div class="collapse navbar-collapse">
			<ul class="nav navbar-nav">
				<li><a href="index.html">首页</a></li>
				<li><a href="diary/diary.html">日记</a></li>
				<li><a href="各类清单.html">清单</a></li>
				<li><a href="文章.html">文章</a></li>
			</ul>
		</div>
	</div>
</nav>
<div class="container content-body">
   
<h2 id="toc_0.1">Minimum Depth of Binary Tree</h2>

<p>
 <strong>Reference</strong>
</p>
<ul>
<li>
<a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">https://leetcode.com/problems/minimum-depth-of-binary-tree/</a>

</ul>

<p>
 <strong>题目要求</strong>
</p>
<ul>
<li>
找出二叉树中从根节点到叶子节点间的最短距离

</ul>

<p>
 <strong>关键点</strong>
</p>
<ul>
<li>
这一题首先要明白最终要找的节点的条件是其左右孩子皆为空。第一反应居然违反了这个原则。

<li>
用层序遍历合适

</ul>

<pre>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == NULL) return 0;
        queue&lt;TreeNode*&gt; que;
        que.push(root);
        que.push(NULL);
        int depth = 1;
        while(!que.empty())
        {
            TreeNode* node = que.front();
            que.pop();
            if (node == NULL) 
            {   
                que.push(NULL);
                depth++;
            }
            else
            {
                if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) return depth;
                if (node-&gt;left != NULL) que.push(node-&gt;left);
                if (node-&gt;right != NULL) que.push(node-&gt;right);
            }
        }
    }
};
</pre>

</div>
</body>
</html>
