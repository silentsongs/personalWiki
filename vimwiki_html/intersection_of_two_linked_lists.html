<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="Stylesheet" type="text/css" href="static/css/wiki.css">
<link rel="Stylesheet" type="text/css" href="static/bootstrap/css/bootstrap.min.css">
<script type="text/javascript" src="static/js/jquery-2.1.4.min.js"></script>
<script type="text/javascript" src="static/bootstrap/js/bootstrap.min.js"></script>
<script type="text/javascript" src="static/js/wiki.js"></script>
<title>intersection_of_two_linked_lists</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>
<nav class="navbar navbar-default navbar-inverse" role="navigation">
	<div class="container">
		<div class="navbar-header">
		<button data-target=".bs-navbar-collapse" data-toggle="collapse" type="button" class="navbar-toggle">
			<span class="sr-only"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>
		<a class="navbar-brand" href="index.html">BlueBird's Wiki</a>
		</div>
		<div class="collapse navbar-collapse">
			<ul class="nav navbar-nav">
				<li><a href="index.html">首页</a></li>
				<li><a href="diary/diary.html">日记</a></li>
				<li><a href="各类清单.html">清单</a></li>
				<li><a href="文章.html">文章</a></li>
			</ul>
		</div>
	</div>
</nav>
<div class="container content-body">
   
<h2 id="toc_0.1">Intersection of Two Linked Lists</h2>

<p>
 <strong>问题描述</strong> ：
找出两个单向链表开始重合的节点。
</p>
<pre>
For example, the following two linked lists:

A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
begin to intersect at node c1.

</pre>

<p>
 <strong>要求</strong> ：
</p>
<ul>
<li>
如果没有重合的节点，返回NULL。

<li>
当方法返回时，两个单向链表的内容没有被改变。

<li>
可以假设不存在循环链表。

<li>
要求O(n)的时间复杂度，O(1)的内存占用。

</ul>

<p>
 <strong>思路</strong> ：
</p>
<ul>
<li>
链表A的长度 + 链表B的长度 - 各自非重合的部分 = 2 * 重合部分的长度

</ul>

<p>
 <strong>注意</strong> ：
</p>
<ul>
<li>
采用这种方式的时候，必须强调只适用于不存在循环的场景下。

</ul>

<pre>
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (headA == NULL || headB == NULL) return NULL;
        ListNode* a = headA;
        ListNode* b = headB;
        while(a != b)
        {   
            a = a-&gt;next;
            b = b-&gt;next;

            if (a == b) return a;
            if (a == NULL) a = headB;
            if (b == NULL) b = headA;
        }   
        return a;
    }
};
</pre>

</div>
</body>
</html>
